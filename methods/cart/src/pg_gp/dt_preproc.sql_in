/* ----------------------------------------------------------------------- *//** 
 *
 * @file dt_preproc.sql_in
 *
 * @brief Functions used in C4.5 and random forest for data preprocessing.
 * @date April 5, 2012
 *
 *//* ----------------------------------------------------------------------- */


m4_include(`SQLCommon.m4')

/* Own macro definitions */
m4_ifelse(
    m4_eval(
        m4_ifdef(`__GREENPLUM__', 1, 0) &&
        __DBMS_VERSION_MAJOR__ * 100 + __DBMS_VERSION_MINOR__ < 401
    ), 1,
    `m4_define(`__GREENPLUM_PRE_4_1__')'
)

/*
 * The UDT for the result of encoding tabular table in training.
 *
 *      pre_proc_time            The time of pre-processing.
 *      unnest_tbl_time          The time of unnest the raw training table.
 *      gen_kv_time              The time of generating KV-table for all features. 
 *      gen_enc_time             The time of generating vertical and horizontal encoded table.
 *      post_proc_time           The time of post-processing.
 *
 */
DROP TYPE IF EXISTS MADLIB_SCHEMA.__enc_tbl_result;
CREATE TYPE MADLIB_SCHEMA.__enc_tbl_result AS 
(     
    pre_proc_time            INTERVAL,
    unnest_tbl_time          INTERVAL,
    gen_kv_time              INTERVAL,
    gen_enc_time             INTERVAL,
    post_proc_time           INTERVAL
);

/*
 * @brief Test if the input value is a missing value or not.
 *
 * @param val   The value to be tested.
 *
 * @note The support missing values are: ' ', NULL AND '?'.
 *       The input value will be trimed from begining and ending.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__is_miss_value
    (
    val TEXT 
    ) 
RETURNS BOOL
AS 'MODULE_PATHNAME', 'dt_is_miss_value'
LANGUAGE C IMMUTABLE;


/*
 * @brief Check if the input table has unsupported data type or not.
 *        Check if the id column of input table has duplicated value or not.
 *
 * @param full_table_name     The full table name.
 * @param feature_columns     The array including all feature names.
 * @param id_column           The name of the ID column.        
 * @param class_column        The name of the class column. 
 *
 * @return If the table has unsupported data types, then raise exception
 *         otherwise return nothing.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__validate_input_table    
    (
    full_table_name     TEXT,
    feature_columns     TEXT[],
    id_column           TEXT,
    class_column        TEXT
    )
RETURNS void AS $$  
DECLARE
    rec             RECORD;
    stmt            TEXT;
    all_columns     TEXT := '';
    index           INT;
BEGIN
    -- find the first (LIMIT 1) unsupported data type if the input table has.
    stmt= 'SELECT atttypid 
    FROM pg_attribute 
    WHERE attrelid ='||quote_literal(full_table_name)||'::regclass  AND
          attnum > 0                                                AND 
          (not attisdropped)                                        AND
          atttypid NOT IN 
          (
              SELECT unnest
                    (
                        ARRAY[
                            ''SMALLINT''::regtype::oid,
                            ''INT''::regtype::oid, 
                            ''BIGINT''::regtype::oid, 
                            ''FLOAT8''::regtype::oid, 
                            ''REAL''::regtype::oid, 
                            ''DECIMAL''::regtype::oid,
                            ''INET''::regtype::oid, 
                            ''CIDR''::regtype::oid, 
                            ''MACADDR''::regtype::oid, 
                            ''BOOLEAN''::regtype::oid, 
                            ''CHAR''::regtype::oid, 
                            ''VARCHAR''::regtype::oid, 
                            ''TEXT''::regtype::oid, 
                            ''"char"''::regtype::oid, 
                            ''DATE''::regtype::oid, 
                            ''TIME''::regtype::oid,
                            ''TIMETZ''::regtype::oid, 
                            ''TIMESTAMP''::regtype::oid, 
                            ''TIMESTAMPTZ''::regtype::oid, 
                            ''INTERVAL''::regtype::oid
                        ]
                    )
          ) ';

    IF (feature_columns IS NOT NULL) THEN
        -- If user do not specify feature columns, we use all those columns.
        -- Otherwise, we just need to check those specified columns.
        index = array_lower(feature_columns, 1);
        WHILE (index <= array_upper(feature_columns, 1)) LOOP
            all_columns = all_columns                           || 
                          quote_literal(feature_columns[index]) || 
                          ',';
            index = index+1;
        END LOOP; 
        
        all_columns = all_columns || quote_literal(id_column) || ',';
        all_columns = all_columns || quote_literal(class_column);
        stmt = stmt ||' AND attname IN ('||all_columns||') ';
    END IF;
    
    stmt = stmt||' LIMIT 1;';
    
    EXECUTE stmt INTO rec;
            
    IF (rec IS NOT NULL) THEN
        -- Print the first unsupported data type, and supported types.
        RAISE EXCEPTION 'Unsupported data type [%]. Supported types include:
                         SMALLINT, INT, BIGINT, FLOAT8, REAL,
                         DECIMAL, INET, CIDR, MACADDR, BOOLEAN,
                         CHAR, VARCHAR, TEXT, "char", 
                         DATE, TIME, TIMETZ, TIMESTAMP, TIMESTAMPTZ, and INTERVAL', 
                         rec.atttypid::regtype;
    END IF;

    SELECT MADLIB_SCHEMA.__format
            ('SELECT % AS n
              FROM % 
              GROUP BY %
              HAVING COUNT(%) > 1
              LIMIT 1',
              ARRAY[
                id_column,
                full_table_name,
                id_column,
                id_column
                ]
            )
    INTO stmt;
    
    EXECUTE stmt INTO rec;
    
    -- check if the id column has duplicated value
    PERFORM MADLIB_SCHEMA.__assert
                (
                    rec IS NULL,
                    'The training table ' || full_table_name || ' must not have duplicated id'
                );
                        
    RETURN;
END
$$ LANGUAGE PLPGSQL;    


/*
 * @brief Get the class table name by the metatable name.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The name of the class table
 *
 */  
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_classtable_name
    (
    meta_tbl_name TEXT 
    ) 
RETURNS TEXT AS $$
DECLARE
    classtable_name TEXT;
    curstmt         TEXT;
BEGIN

    PERFORM MADLIB_SCHEMA.__assert_table
        (
            meta_tbl_name,
            't'
        ); 
          
    curstmt = MADLIB.__format
        (
            'SELECT MADLIB_SCHEMA.__regclass_to_text
                (table_oid) as table_name 
             FROM %
             WHERE column_type = ''c''',
            ARRAY[
                meta_tbl_name
            ]
        );
    
    EXECUTE curstmt INTO classtable_name;
    
    RETURN classtable_name;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Drop the metatable and KV table for features and class.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__drop_metatable 
    (
    meta_tbl_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    name    TEXT;
BEGIN
    IF (meta_tbl_name is NULL ) THEN
        RETURN;
    END IF;
    
    PERFORM MADLIB_SCHEMA.__assert_table(meta_tbl_name, 't');
    
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT MADLIB_SCHEMA.__regclass_to_text
                (min(table_oid)) as table_name 
             FROM % 
             WHERE table_oid IS NOT NULL
             GROUP BY column_type, is_cont',
             ARRAY[
                 meta_tbl_name
             ]
        );
        
    FOR name IN EXECUTE curstmt LOOP
        EXECUTE 'DROP TABLE IF EXISTS ' || name || ' CASCADE;';
    END LOOP;
    
    EXECUTE 'DROP TABLE ' || meta_tbl_name || ' CASCADE;';
end
$$ LANGUAGE PLPGSQL;


/*
 * @brief Create the metatable. 
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__create_metatable 
    (
    meta_tbl_name TEXT
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    -- the maximum length of an identifier is 63
    PERFORM MADLIB_SCHEMA.__assert
        (
            length(MADLIB_SCHEMA.__strip_schema_name(meta_tbl_name)) <= 63, 
            'The maximum length of '                            ||
             MADLIB_SCHEMA.__strip_schema_name(meta_tbl_name)  || 
             ' is 63'
        );
        
    -- must not be existence
    PERFORM MADLIB_SCHEMA.__assert_table(meta_tbl_name, 'f');
    
    -- 'f' for feature, 'c' for class, 'i' for id
    -- 't' for continuous value, 'f' for discrete value
    curstmt = MADLIB_SCHEMA.__format
        (
            'CREATE TABLE %(
             id             INT,
             column_name    TEXT,
             column_type    TEXT,
             is_cont        BOOL,
             table_oid      OID,
             num_dist_value INT
             ) m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (id)')',
            meta_tbl_name
        );
    EXECUTE curstmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Insert a record to the metatable
 *        A row in the metatable represents a column's information.
 *
 * @param meta_tbl_name     The full name of the metatable.
 * @param column_name       The name of the column.
 * @param column_type       The type of the column.
 *                          'i' means id, 'c' means class, 'f' means feature.
 * @param is_cont           True if the column is continuous.
 * @param table_name        The full name of key-value table for the column.
 *                          The OID of this table will be stored.
 * @param num_dist_value    The number of distinct values for the column.
 *
 * @note  The null value will be included in the distinct values.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__insert_into_metatable 
    (
    meta_tbl_name       TEXT,
    col_index           INT,
    column_name         TEXT,
    column_type         CHAR,   
    is_cont             BOOLEAN,     
    table_name          TEXT,
    num_dist_value      INT         
    )
RETURNS void AS $$
DECLARE
    curstmt TEXT := '';
    tbl_txt TEXT := 'NULL';     
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            column_type = 'f' OR column_type = 'i' OR column_type = 'c',
            'column type must be ''f'', ''i'' or ''c'''
        );
    IF (table_name IS NOT NULL) THEN
        tbl_txt = '''' || table_name || '''';
    END IF;

    curstmt = MADLIB_SCHEMA.__format
        (
            'INSERT INTO % VALUES
                (%, ''%'', ''%'', ''%'', %::regclass, %);',
            ARRAY[
                meta_tbl_name, 
                col_index::TEXT,
                column_name, 
                column_type, 
                MADLIB_SCHEMA.__to_char(is_cont), 
                tbl_txt,
                num_dist_value::TEXT
            ]
        ); 

    EXECUTE curstmt;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of distinct values for the feature with given ID.
 *
 * @param meta_tbl_name     The full name of the metatable.
 * @param feature_id        The ID of the feature in the metatable.
 *
 * @return The number of the distinct values for the given feature.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__distinct_feature_value 
    (
    meta_tbl_name   TEXT,
    feature_id      INT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt     TEXT := '';
    result      INT4 := 0;
BEGIN
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT num_dist_value 
             FROM % 
             WHERE column_type=''f'' AND id = %',
            meta_tbl_name,
            feature_id::TEXT
        ); 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of features.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The number of features in the training table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_feature 
    (
    meta_tbl_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt TEXT := '';
    result INT4 := 0;
BEGIN
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT COUNT(*) 
             FROM % 
             WHERE column_type=''f''',
            meta_tbl_name
        ); 
                
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of distinct class values.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The number of class labels in the training table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__num_of_class
    (
    meta_tbl_name TEXT
    )
RETURNS INT4 AS $$
DECLARE
    curstmt             TEXT := '';
    result              INT4 := 0;
    class_table_name    TEXT := '';
BEGIN
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT MADLIB_SCHEMA.__regclass_to_text(table_oid) 
             FROM % 
             WHERE column_type=''c''',
            meta_tbl_name
        ); 
                
    EXECUTE curstmt INTO class_table_name;
    
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT COUNT(code)
             FROM %',
            class_table_name
        );
    
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the number of discrete features.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The number of discrete features.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_num_discete_features    
    (
    meta_tbl_name  TEXT
    )
RETURNS INT AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT count(id) 
             FROM  % 
             WHERE column_type = ''f'' AND (NOT is_cont)',
            ARRAY[
                meta_tbl_name
            ]
        );
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature ID by the specified feature name.
 *
 * @param feature_name      The name of the feature.
 * @param meta_tbl_name     The full name of the metatable.
 *
 * @return The feature ID.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_index    
    (
    feature_name    TEXT,
    meta_tbl_name   TEXT
    )
RETURNS INT AS $$
DECLARE
    curstmt TEXT;
    result  INT := 0;
BEGIN
    curstmt = MADLIB_SCHEMA.__format
            (
                'SELECT id 
                 FROM  % 
                 WHERE column_name=''%'' AND 
                       column_type = ''f'' 
                 LIMIT 1;',
                ARRAY[
                    meta_tbl_name,
                    feature_name
                ]
            );
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature name by the specified feature ID.
 *
 * @param feature_index     The ID of the feature.
 * @param meta_tbl_name     The full name of the metatable.
 *
 * @return The feature name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_name    
    (
    feature_index   INT,
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT column_name 
             FROM   % 
             WHERE  id = % AND column_type = ''f'';',
            meta_tbl_name,
            MADLIB_SCHEMA.__to_char(feature_index)
        );
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the column value by the specified column ID and code.
 *
 * @param column_index      The ID of the column.
 * @param code              The code of the column value.
 * @param column_type       The type of the column.
 *                          'i' means id, 'c' means class, 'f' means feature.
 * @param meta_tbl_name     The full name of the metatable.
 * 
 * @return The column's value corresponding to the give code. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_column_value    
    (
    column_index    INT,
    code            INT,
    column_type     CHAR,
    meta_tbl_name   TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    curstmt     TEXT;
    names       TEXT[];
    result      TEXT := '';
    tmp_txt     TEXT := ' WHERE column_type = ''c''';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert
        (
            code IS NOT NULL, 
            'the code of the value should not be null'
        );

    IF (column_type <> 'c') THEN
        tmp_txt = MADLIB_SCHEMA.__format
            (
                ' WHERE id = % AND column_type = ''%''', 
                column_index::TEXT, 
                column_type::TEXT
            );
    END IF;

    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT 
                 ARRAY[column_name, 
                       MADLIB_SCHEMA.__regclass_to_text(table_oid)] 
             FROM % 
             %',
            meta_tbl_name,
            tmp_txt
        ); 
                   
    EXECUTE curstmt INTO names;
    
    PERFORM MADLIB_SCHEMA.__assert(names[1] IS NOT NULL, 'No such column name');
    PERFORM MADLIB_SCHEMA.__assert(names[2] IS NOT NULL, 'No such table name');
    
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT MADLIB_SCHEMA.__to_char(fval) 
             FROM % 
             WHERE code = %;',
            names[2],
            code::TEXT
        );

    EXECUTE curstmt INTO result;
    
    IF (result IS NULL) THEN
        result = 'NULL';
    END IF;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the feature value by the specified feature ID and code.
 *
 * @param feature_index     The ID of the feature.
 * @param code              The code of the feature value.
 * @param meta_tbl_name     The full name of the metatable.  
 *
 * @return The value of specified code of the feature 
 *         whose id specified in feature_index.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_feature_value    
    (
    feature_index   INT,
    code            INT,
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    result = MADLIB_SCHEMA.__get_column_value
        (
            feature_index, 
            code, 
            'f', 
            meta_tbl_name
        );
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the ID column name.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The ID column name.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_id_column_name    
    (
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert_table
        (
            meta_tbl_name,
            't'
        );
        
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT column_name 
             FROM   % 
             WHERE  column_type = ''i'' 
             LIMIT 1',
            meta_tbl_name
        );
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the class column name.
 *
 * @param meta_tbl_name    The full name of the metatable.
 *
 * @return The class column name. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_column_name    
    (
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$
DECLARE
    curstmt TEXT;
    result  TEXT := '';
BEGIN
    PERFORM MADLIB_SCHEMA.__assert_table
        (
            meta_tbl_name,
            't'
        );
        
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT column_name 
             FROM   % 
             WHERE  column_type = ''c'' LIMIT 1',
            meta_tbl_name
        );
        
    EXECUTE curstmt INTO result;
    
    RETURN result;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Get the class value by the specified code.
 *
 * @param code               The code of the class value.
 * @param meta_tbl_name      The full name of the metatable.
 *
 * @return The class value corresponding to the code. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__get_class_value    
    (
    code            INT,
    meta_tbl_name  TEXT
    )
RETURNS TEXT AS $$  
DECLARE
    result TEXT := '';
BEGIN
    result = MADLIB_SCHEMA.__get_column_value(0, code, 'c', meta_tbl_name);
            
    RETURN result;
END
$$ LANGUAGE PLPGSQL;  


/*
 * @brief Unnest each record from the training table.
 *        For example, we have the training table t(id, f1, f2, f3, class), 
 *        then the unnested table is ut(id, fid, fval, is_cont, class). 
 *        The id column of the two tables is the same. Each feature will be
 *        encoded to continuous numeric number. Assume that t has values
 *        (1, 'a', 1, 10, '+'), (2, 'b', 2, 8, '-') and (3, 'd', null, 2, '+'), 
 *        and all of them are discrete features, then the values of ut are 
 *        (1, 1, 'a', 'f', '+'), (2, 1, 'b', 'f', '-'), (3, 1,  'd', 'f', '+')
 *        (1, 2,   1, 'f', '+'), (2, 2,   2, 'f', '-'), (3, 2, null, 'f', '+')
 *        (1, 3,  10, 'f', '+'), (2, 3,   8, 'f', '-'), (3, 3,    2, 'f', '+')
 *
 * @param input_tbl_name      The full name of the input training table.
 * @param unnest_tbl_name     The name of the unnested table.
 * @param cls_map_name        The name of the key-value table for class column.
 * @param id_col_name         The name of the ID column. 
 * @param feat_col_names      The array contains all the features' names.
 * @param is_feat_conts       The subscript of the array denotes the feature index.
 *                            Each value of the array denotes the feature is
 *                            continuousi ('t') or discrete ('f')
 * @param verbosity           > 0 means this function runs in verbose mode. 
 *
 * @return The name of the unnested table, which will be used to generate the encoded
 *         vertical table and horizontal table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__unnest_table
    (
    input_tbl_name        TEXT, 
    unnest_tbl_name       TEXT,
    cls_map_name          TEXT,
    id_col_name           TEXT,
    cls_col_name          TEXT,
    feat_col_names        TEXT[],
    is_feat_conts         BOOL[],
    verbosity             INT
    ) 
RETURNS VOID AS $$
DECLARE
    curstmt             TEXT;
    exec_begin          TIMESTAMP;
BEGIN
    exec_begin = clock_timestamp();
    
    EXECUTE 'DROP TABLE IF EXISTS ' || unnest_tbl_name;
    
    IF (cls_col_name IS NULL) THEN
        -- if the cls_map_name is null, then the class column will be null        
        curstmt = MADLIB_SCHEMA.__format
            (
                'CREATE TEMP TABLE %(id, fid, fval, is_cont, class) AS
                 SELECT id, fid, 
                     CASE WHEN (MADLIB_SCHEMA.__is_miss_value(fval)) THEN
                        NULL::TEXT
                     ELSE 
                        fval
                     END as fval,
                     is_cont, class
                 FROM 
                    (
                     SELECT %, generate_series(1, %) as fid, 
                        unnest(array[MADLIB_SCHEMA.__to_char(%)]) as fval, 
                        unnest(array[''%''::BOOL]::BOOL[]) as is_cont, NULL as class
                     FROM
                        % t1
                    ) t
                  m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (id)')',
                ARRAY[
                    unnest_tbl_name,
                    id_col_name,
                    array_upper(is_feat_conts, 1)::TEXT,
                    array_to_string(feat_col_names, '), MADLIB_SCHEMA.__to_char('),
                    array_to_string(is_feat_conts, ''','''),
                    input_tbl_name
                ]
            );

    ELSE
        curstmt = MADLIB_SCHEMA.__format
            (
                'CREATE TEMP TABLE %(id, fid, fval, is_cont, class) AS
                 SELECT id, fid, 
                     CASE WHEN (MADLIB_SCHEMA.__is_miss_value(fval)) THEN
                        NULL::TEXT
                     ELSE 
                        fval
                     END as fval,
                     is_cont, class
                 FROM 
                    (
                     SELECT %, generate_series(1, %) as fid, 
                        unnest(array[MADLIB_SCHEMA.__to_char(%)]) as fval, 
                        unnest(array[''%''::BOOL]::BOOL[]) as is_cont,
                        code as class
                     FROM
                        % t1, % t2
                     WHERE MADLIB_SCHEMA.__to_char(t1.%) = t2.fval                    
                    ) t
                 m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (id)')',
                ARRAY[
                    unnest_tbl_name,
                    id_col_name,
                    array_upper(is_feat_conts, 1)::TEXT,
                    array_to_string(feat_col_names, '), MADLIB_SCHEMA.__to_char('),
                    array_to_string(is_feat_conts, ''','''),
                    input_tbl_name,
                    cls_map_name, 
                    cls_col_name                    
                ]
            );
    END IF;

    IF (verbosity > 0) THEN
        RAISE INFO '%', curstmt;
    END IF;
    EXECUTE curstmt;
    
    IF (verbosity > 0) THEN
        RAISE INFO 'time of unnesting the raw training table:%', 
            clock_timestamp() - exec_begin;
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Generate the encoded tables (vertical table and horizontal table)
 *        For example, the schema of input table is t(id, f1, f2, f3, class),
 *        then the schema of horizontal table is ht(id, array[ef1, ef2, ef3], class)
 *        efi means the encoded result for the ith feature.
 *        The vertical table is vt(id, fid, fval, is_cont, class). 
 *        The vertical table will be used to generate ACC. The horizontal table will
 *        be used to update the assigned node ID for each sample in training set.
 *
 * @param input_tbl_name      The full name of the input training table.
 * @param ver_tbl_name        The name of the vertical table.
 * @param hor_tbl_name        The name of the horizontal table.
 * @param feat_map_name       The name of the key-value table contains the encoded
 *                            result for all the features. For continuous feature,
 *                            it kept the average value of it if in 'explicit' mode;
 *                            nothing will kept if in 'ignore' mode.
 * @param is_tbl_tmp          If ture we will create the vertical and horizontal table
 *                            as temp table.
 * @param verbosity           > 0 means this function runs in verbose mode. 
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__gen_encoded_table
    (
    input_tbl_name        TEXT,     
    ver_tbl_name          TEXT,
    hor_tbl_name          TEXT,
    feat_map_name         TEXT,
    is_tbl_tmp            BOOL,
	feat_count			  INT,
    verbosity             INT
    ) 
RETURNS VOID AS $$
DECLARE
    curstmt             TEXT;
    exec_begin          TIMESTAMP;
    tmp_txt             TEXT = '';
BEGIN
    exec_begin = clock_timestamp();

    IF (is_tbl_tmp) THEN
        tmp_txt = ' TEMP ';
    END IF;
               
    EXECUTE 'DROP TABLE IF EXISTS ' || ver_tbl_name;
    curstmt = MADLIB_SCHEMA.__format
        (
            'CREATE TEMP TABLE %(id, fid, fval, is_cont, class) AS
             SELECT p.id AS id, p.fid AS fid,
                 CASE WHEN (p.is_cont AND p.fval IS NOT NULL) THEN
                    p.fval::FLOAT8
                 ELSE 
                    m.code::FLOAT8 
                 END AS fval,
                 p.is_cont AS is_cont,
                 p.class::INT AS class
            FROM
                % p LEFT JOIN % m
            ON
                m.fid = p.fid AND
                (coalesce(m.fval, '''') = (coalesce(p.fval, '''')))
            m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (id)')',
            ARRAY[            
                ver_tbl_name,
                input_tbl_name,
                feat_map_name
            ]
        );
    IF (verbosity > 0) THEN
        RAISE INFO '%', curstmt;
    END IF;
    EXECUTE curstmt;

    IF (verbosity > 0) THEN
        RAISE INFO 'time of generating vertical encoded table:%', 
            clock_timestamp() - exec_begin;
    END IF;

    EXECUTE 'DROP TABLE IF EXISTS ' || hor_tbl_name;
    curstmt = MADLIB_SCHEMA.__format
        (
            'CREATE % TABLE %(id, fvals, class) AS
             SELECT 
                 id, 
				 madlib.__array_indexed_agg(fval, %, fid) as fvals,
                 min(class)::INT as class
             FROM %
             GROUP BY id
             m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (id)')',
            ARRAY[
                tmp_txt,
                hor_tbl_name,
				feat_count::TEXT,
                ver_tbl_name
            ]
        );
    IF (verbosity > 0) THEN
        RAISE INFO '%', curstmt;
    END IF;
    EXECUTE curstmt;

    EXECUTE 'DROP TABLE IF EXISTS ' || input_tbl_name;
      
    IF (verbosity > 0) THEN
        RAISE INFO 'time of generating vertical and horizontal encoded table:%', 
            clock_timestamp() - exec_begin;
    END IF;
END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Encode the continuous and discrete features and the class column.
 *        In 'ignore' mode, for each discrete feature/class, we will use 
 *        continuous integer to encode each distinct value (null value 
 *        will be excluded). Continuous feature will not be processed. 
 *        In 'explicit' mode, null value will be included for discrete 
 *        feature. For continuous feature, null value will be replaced by
 *        the average value of this feature.
 * 
 * @param feat_map_name       The name of the key-value table contains the encoded
 *                            result for all the features. For continuous feature,
 *                            it kept the average value of it if in 'explicit' mode;
 *                            nothing will kept if in 'ignore' mode.
 * @param unnest_tbl_name     The name of the unnested table from raw training table.
 * @param cls_map_name        The name of the key-value table for class column.
 * @param h2hmv_routine_id    The ID of the routine which specifies 
 *                            How to handle missing value(h2hmv).
 * @param verbosity           > 0 means this function runs in verbose mode.
 *
 * @return The name of the unnested table, which will be used to generate the encoded
 *         vertical table and horizontal table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_columns
    (
    feat_map_name       TEXT,
    unnest_tbl_name     TEXT,
    h2hmv_routine_id    INT,
    verbosity           INT
    )
RETURNS VOID AS $$
DECLARE
    curstmt             TEXT;
    tmp_txt		TEXT = '';
BEGIN
    IF (h2hmv_routine_id = 1) THEN
        tmp_txt = ' WHERE fval IS NOT NULL';
    END IF;

    EXECUTE 'DROP TABLE IF EXISTS tmp_dist_table';
	curstmt = MADLIB_SCHEMA.__format
		(
			'CREATE TEMP TABLE tmp_dist_table AS 
			 SELECT fid, fval, is_cont 
			 FROM %
			 %
			 GROUP BY fid, fval, is_cont',
			ARRAY[
				unnest_tbl_name,
                tmp_txt
			]
		);
    IF (verbosity > 0) THEN
        RAISE INFO '%', curstmt;
    END IF;

	EXECUTE curstmt;

    EXECUTE 'DROP TABLE IF EXISTS ' || feat_map_name;
	curstmt = MADLIB_SCHEMA.__format
		(
			'CREATE TABLE %(fid, fval, code) AS
		     SELECT
				fid,
				fval,
				(rank() OVER (PARTITION BY fid ORDER BY fval))::FLOAT8 AS code
			 FROM tmp_dist_table
			 WHERE (NOT is_cont)
			 m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (fid, fval)')',
			ARRAY[
				feat_map_name
			]
		);
    IF (verbosity > 0) THEN
        RAISE INFO '%', curstmt;
    END IF;

	EXECUTE curstmt;

    IF (h2hmv_routine_id = 2) THEN
        curstmt = MADLIB_SCHEMA.__format
            (
                'INSERT INTO %(fid, fval, code)
                    SELECT
                        fid,
                        null, 
                        coalesce(avg(fval::FLOAT8), 0.0)
                    FROM
                        % s 
                    WHERE is_cont
                    GROUP BY fid',
                ARRAY[
                    feat_map_name,
                    unnest_tbl_name
                ]
            );         
        IF (verbosity > 0) THEN
            RAISE INFO '%', curstmt;
        END IF;

        EXECUTE curstmt;
    END IF;

END
$$ LANGUAGE PLPGSQL;


/*
 * @brief Encode a tabular table for training.
 *
 * @param input_tbl_name      The full name of the input table.
 * @param id_column_name      The name of id column.
 * @param feature_names       An array contains all the feature. If it's null, 
 *                            we will get all the columns of the input table.
 * @param class_column_name   The name of class column.
 * @param feat_cont_names     An array contains all the continuous feature.
 *                            Null means no continuous feature.
 * @param encoded_table_name  The full name of the encoded table.
 * @param meta_tbl_name       The full name of the metatable.
 * @param h2hmv_routine_id    The ID of the routine which specifies 
 *                            How to handle missing value(h2hmv).
 * @param verbosity           > 0 means this function runs in verbose mode. 
 *
 * @return The full name of the encoded table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_tbl_name      TEXT, 
    id_col_name         TEXT, 
    feature_names       TEXT[],
    cls_col_name        TEXT, 
    feat_cont_names     TEXT[], 
    encoded_table_name  TEXT,
    meta_tbl_name       TEXT,
    h2hmv_routine_id    INT,
    verbosity           INT
    ) 
RETURNS TEXT    AS $$
DECLARE
    column_name         TEXT :='';
    curstmt             TEXT := '';
    feat_col_names      TEXT[]; 
    -- the map table for the feature 
    -- each feature value will be encoded to continuous integer)
    feat_map_name       TEXT := encoded_table_name || '_col';
    -- the map table for the class 
    -- (each class label will be encoded to continuous integer)
    cls_map_name        TEXT := encoded_table_name || '_class';
    is_feat_conts       BOOL[];
    exec_begin          TIMESTAMP;
    unnest_tbl_name     TEXT := 'tmp_unnest_table';
    ret                 MADLIB_SCHEMA.__enc_tbl_result;
BEGIN
    exec_begin = clock_timestamp();
        
    -- validate the training table
    PERFORM MADLIB_SCHEMA.__validate_input_table
        (
            input_tbl_name,
            feature_names,
            id_col_name,
            cls_col_name
        );
    
    -- create metatable
    PERFORM MADLIB_SCHEMA.__create_metatable(meta_tbl_name);
    
    -- retrieve all the features' names
    IF (feature_names IS NULL) THEN
m4_changequote(`>>>', `<<<')
m4_ifdef(`__HAS_ORDERED_AGGREGATES__', >>>
        curstmt = MADLIB_SCHEMA.__format
            (
                'SELECT array_agg(attname ORDER BY attname) as attnames 
                 FROM   pg_attribute 
                 WHERE  attrelid = ''%''::regclass and attnum > 0 AND 
                        attname <> ''%'' AND
                        attname <> ''%'' AND
                        NOT attisdropped;', 
                ARRAY[
                    input_tbl_name,
                    id_col_name,
                    cls_col_name
                ]
            );   
        
        EXECUTE curstmt INTO feat_col_names;
<<<, >>>
        curstmt = MADLIB_SCHEMA.__format
            (
                'SELECT ARRAY
                 (
                 SELECT attname 
                 FROM   pg_attribute 
                 WHERE  attrelid = ''%''::regclass and attnum > 0 AND 
                        attname <> ''%'' AND
                        attname <> ''%'' AND
                        NOT attisdropped
                 ORDER BY attname
                 LIMIT ALL
                 )', 
                ARRAY[
                    input_tbl_name,
                    id_col_name,
                    cls_col_name
                ]
            );          
        EXECUTE curstmt INTO feat_col_names;
<<<)
m4_changequote(>>>`<<<, >>>'<<<)    
    ELSE
        feat_col_names = MADLIB_SCHEMA.__array_sort(feature_names);
    END IF;

    -- an array contains a feature is continuous or not
    -- the subscript is corresponding to the feature ID 
    is_feat_conts = MADLIB_SCHEMA.__array_in(feat_cont_names, feat_col_names);

    ret.pre_proc_time = clock_timestamp() - exec_begin;
    exec_begin = clock_timestamp();
    
    EXECUTE 'DROP TABLE IF EXISTS ' || cls_map_name;
    curstmt = MADLIB_SCHEMA.__format
            (
                'CREATE TABLE % AS
                    SELECT 0 as fid, 
                        MADLIB_SCHEMA.__to_char(%) AS fval, 
                        rank() OVER (ORDER BY %) AS code
                    FROM 
                        (
                            SELECT % FROM % GROUP BY %
                        ) t
                 m4_ifdef(`__GREENPLUM__', `DISTRIBUTED BY (fval)')',
                ARRAY[
                    cls_map_name,
                    cls_col_name,
                    cls_col_name,
                    cls_col_name,
                    input_tbl_name,
                    cls_col_name
                ]
            );
    IF (verbosity > 0) THEN
        RAISE INFO '%', curstmt;
    END IF;

    EXECUTE curstmt;
    
    ret.gen_kv_time = clock_timestamp() - exec_begin;
    exec_begin = clock_timestamp();

    PERFORM MADLIB_SCHEMA.__unnest_table
        (
            input_tbl_name,
            unnest_tbl_name,
            cls_map_name,
            id_col_name,
            cls_col_name,
            feat_col_names,
            is_feat_conts,
            verbosity
        );  

    ret.unnest_tbl_time = clock_timestamp() - exec_begin;
    exec_begin = clock_timestamp();
                
    PERFORM MADLIB_SCHEMA.__encode_columns
        (   
            feat_map_name,
            unnest_tbl_name,
            h2hmv_routine_id,
            verbosity
        );
    
    ret.gen_kv_time = ret.gen_kv_time + (clock_timestamp() - exec_begin);
    exec_begin = clock_timestamp();

    PERFORM MADLIB_SCHEMA.__gen_encoded_table
        (
            unnest_tbl_name, 
            'training_table_vertical',
            encoded_table_name,
            feat_map_name,
            'f'::BOOL,
			array_upper(is_feat_conts, 1),
            verbosity
        );  
        
    ret.gen_enc_time = clock_timestamp() - exec_begin;
    exec_begin = clock_timestamp();
    
    IF (h2hmv_routine_id = 1) THEN
        EXECUTE 'DELETE FROM training_table_vertical
                 WHERE fval IS NULL'; 
    END IF;

    -- put the features' meta information to the metatable
    curstmt = MADLIB_SCHEMA.__format
        (
            'INSERT INTO %
             SELECT fid as id, (ARRAY[''%''])[fid] as column_name,
                    ''f'' as column_type,
                    is_cont,
                    ''%''::regclass::OID,
                count(fid) as num_dist_value
             FROM % t
             GROUP BY fid, is_cont',
            ARRAY[
                meta_tbl_name,
                array_to_string(feat_col_names, ''','''),
                feat_map_name,                
                'tmp_dist_table'
            ]
        );

    EXECUTE curstmt;

    -- put the class's meta information to the metatable
    curstmt = MADLIB_SCHEMA.__format
        (
            'INSERT INTO %
             SELECT 0 as id,''%'',
                    ''c'' as column_type,
                    ''f''::BOOL,
                    ''%''::regclass::OID,
                count(code) as num_dist_value
             FROM % t
             GROUP BY fid',
            ARRAY[
                meta_tbl_name,
                cls_col_name,
                cls_map_name,                
                cls_map_name
            ]
        );

    EXECUTE curstmt;

    -- put the id's meta information to the metatable
    PERFORM MADLIB_SCHEMA.__insert_into_metatable
        (
            meta_tbl_name, 
            array_upper(feat_col_names, 1) + 1, 
            id_col_name, 
            'i', 'f', NULL, 0
        );

    ret.post_proc_time = clock_timestamp() - exec_begin;
    
    IF (verbosity > 0) THEN
        RAISE INFO '%', ret;
        RAISE INFO 'Total encoding time:%', clock_timestamp() - exec_begin;
    END IF;
    
    -- analyze the table, so that later the optimizer has the statistics
    -- information about this table
    EXECUTE 'ANALYZE training_table_vertical';
    
    RETURN encoded_table_name;
END
$$ LANGUAGE PLPGSQL;  


/*
 * @brief Encode a tabular table for classification/scoring.
 *
 * @param input_tbl_name        The full name of the input table.
 * @param enc_tbl_name          The full name of the encoded table.
 * @param meta_tbl_name         The full name of the metatable.
 * @param h2hmv_routine_id      The ID of the routine which specifies 
 *                              how to handle missing value(h2hmv). 
 * @param verbosity             > 0 means this function runs in verbose mode. 
 *
 * @return The name of the encoded table.
 *
 */
CREATE OR REPLACE FUNCTION MADLIB_SCHEMA.__encode_tabular_table
    (
    input_tbl_name      TEXT, 
    enc_tbl_name        TEXT,
    meta_tbl_name       TEXT,
    h2hmv_routine_id    INT,
    verbosity           INT
    ) 
RETURNS TEXT AS $$
DECLARE
    curstmt             TEXT;
    feat_col_names      TEXT[];
    cls_col_name        TEXT;
    id_col_name         TEXT;
    feat_map_name       TEXT;
    cls_map_name        TEXT;
    is_feat_conts       BOOL[];
    exec_begin          TIMESTAMP;
    unnest_tbl_name     TEXT := 'tmp_unnest_table';
BEGIN
    exec_begin = clock_timestamp();

    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT column_name FROM % WHERE column_type=''i''',
            meta_tbl_name
        ); 
    EXECUTE curstmt INTO id_col_name;

    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT column_name FROM % WHERE column_type=''c''',
            meta_tbl_name
        ); 
    EXECUTE curstmt INTO cls_col_name;

    IF (NOT MADLIB_SCHEMA.__column_exists(input_tbl_name, cls_col_name)) THEN
        cls_col_name = NULL;
    END IF;

m4_changequote(`>>>', `<<<')
m4_ifdef(`__HAS_ORDERED_AGGREGATES__', >>>
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT array_agg(column_name order by id) 
             FROM % WHERE column_type=''f''',
            meta_tbl_name
        ); 
    EXECUTE curstmt INTO feat_col_names;

    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT 
                array_agg(is_cont order by id) 
             FROM % 
             WHERE column_type=''f''',
            meta_tbl_name
        ); 
    EXECUTE curstmt INTO is_feat_conts;
<<<, >>>
    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT ARRAY
             (
              SELECT column_name 
              FROM % WHERE column_type=''f''
              ORDER BY id
              LIMIT ALL
             )',
            meta_tbl_name
        ); 
    EXECUTE curstmt INTO feat_col_names;

    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT ARRAY
             (
              SELECT is_cont 
              FROM % 
              WHERE column_type=''f''
              ORDER BY id
              LIMIT ALL
             )',
            meta_tbl_name
        ); 
    EXECUTE curstmt INTO is_feat_conts;
<<<)
m4_changequote(>>>`<<<, >>>'<<<)

    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT 
                MADLIB_SCHEMA.__regclass_to_text(table_oid) as table_name 
             FROM % 
             WHERE column_type=''f'' limit 1',
            meta_tbl_name
        ); 
    EXECUTE curstmt INTO feat_map_name;

    curstmt = MADLIB_SCHEMA.__format
        (
            'SELECT 
                MADLIB_SCHEMA.__regclass_to_text(table_oid) as table_name 
             FROM % 
             WHERE column_type=''c'' limit 1',
            meta_tbl_name
        ); 
    EXECUTE curstmt INTO cls_map_name;

    PERFORM MADLIB_SCHEMA.__validate_input_table
        (
            input_tbl_name,
            NULL,
            id_col_name,
            NULL
        );

    PERFORM MADLIB_SCHEMA.__unnest_table
        (
            input_tbl_name, 
            unnest_tbl_name,
            cls_map_name,
            id_col_name,
            cls_col_name,
            feat_col_names,
            is_feat_conts,
            verbosity
        );  

    PERFORM MADLIB_SCHEMA.__gen_encoded_table
        (
            unnest_tbl_name, 
            enc_tbl_name || '_v',
            enc_tbl_name,
            feat_map_name,
            't'::BOOL,
			array_upper(is_feat_conts, 1),
            verbosity
        );      

    IF (verbosity > 0) THEN
        RAISE INFO 'Encoding time:%', clock_timestamp() - exec_begin;
    END IF;
        
    RETURN enc_tbl_name;
END
$$ LANGUAGE PLPGSQL;
